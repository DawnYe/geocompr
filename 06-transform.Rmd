# Reprojections and Transformations {#transform}

## Prerequisites {-}

- This chapter requires the packages **tidyverse**, **sf**, **raster**, **spData**, and **spDataLarge**:

```{r, message=FALSE}
library(tidyverse)
library(sf)
library(raster)
library(spData)
library(spDataLarge)
```

## Introduction

As stated in Chapter \@ref(crs-intro), it is important to understand which CRS you are working in when undertaking spatial operations.
Many spatial operations assume that you are using a *projected* CRS (on a Euclidean grid with units of meters rather than a geographic 'lat/lon' grid with units of degrees).
The GEOS engine underlying most spatial operations in **sf**, for example, assumes your data is in a projected CRS.
For this reason **sf** contains a function for checking if geometries have a geographic or projected CRS.
This is illustrated below using the example of *London*:

```{r}
london = st_sf(geometry = st_sfc(st_point(c(-0.1, 51.5))))
st_is_longlat(london)
```

The results show that when geographic data is created from scratch, or is loaded from a source that has no CRS metadata, the CRS is unspecified by default.
CRS can be set with the `st_set_crs` function:^[CRS could be also added when creating the object with the following command: `st_sf(geometry = st_sfc(st_point(c(-0.1, 51.5))), crs = 4326)`]

```{r}
london = st_set_crs(london, 4326)
st_is_longlat(london)
```

Spatial operations on objects without a CRS run on the implicit assumption that they are projected, even when in reality they are not.
This can be seen by creating a buffer of one degree around the `london` point:

```{r}
london_buff = st_buffer(london, dist = 1)
```

As a result a warning message is emitted to warn the user that the operation may not work correctly and that, if the operation was intended, the distance should be in degrees (not meters or some other Euclidean distance measurement).
The seemingly small difference in setting the CRS may seem inconsequential but it can have a huge impact.
This is illustrated in Figure \@ref(fig:crs-buf), which shows how the buffer created in the geographic CRS is dramatically elongated in the north-south direction due to the thinning of the vertical lines of longitude towards the Earth's poles.  

```{r crs-buf, fig.cap="Buffer on data with geographic CRS.", fig.height=5}
plot(london_buff, graticule = st_crs(4326), axes = TRUE)
plot(london, add = TRUE)
```

To prevent this, we need to create a buffer based on a point in a projected CRS.
For example, London has coordinates of `c(530000, 180000)` in British National Grid CRS (EPSG:27700):

```{r}
london_proj = st_sf(geometry = st_sfc(st_point(c(530000, 180000))), crs = 27700)
```

This projected CRS has units in meters. 
One degree at the equator represents 111,319.9 meters and we can use this value to create our buffer:

```{r}
london_proj_buff = st_buffer(london_proj, 111319.9)
```

The result in Figure \@ref(fig:crs-buf-proj) shows that buffers based on a projected CRS are not distorted and we can expect the same distance from our point to the buffer's border.

```{r, echo=FALSE}
options(scipen = 99)
```

```{r crs-buf-proj, fig.cap="Buffer on data with projected CRS.", fig.height=5}
plot(london_proj_buff, graticule = st_crs(27700), axes = TRUE)
plot(london_proj, add = TRUE)
```

## CRS transformation

While CRSs can be set manually, it is more common in real world applications to *transform* a known CRS into another.
CRS transformation could be vital to obtain proper results in many cases.
A typical example is when geometry data is provided in a geographic CRS but you want to do spatial operations, which require it to be in a projected CRS.
It includes distance measurements or area calculations.
CRS also represent spatial relationship between datasets.
Therefore, spatial operations on many datasets can only be correctly performed when all the data have the same CRS.
The most common reason to unify the CRS is to combine different datasets (e.g. merge two rasters) or apply methods which need at least two objects (e.g spatial subsetting or raster map algebra).
Let's use real-world examples to illustrate this.

### Vector data

Vector data on the most basic level is represented by individual points, and points create more complex objects, such as lines and polygons.
Spatial reprojection of vectors is a mathematical transformation of coordinates of these point.
Depending on projections used, reprojection could be either lossy or lossless.
For example, loss of spatial information could occur when the new CRS is only adequate for smaller area than input vector.
The precision could be also lost when transformation is between coordinate systems that have different datum - in those situations approximations are used.
However, in most cases CRS vector transformation is lossless.

<!-- example of using epsg (without "magic number") -->
<!-- example of using proj4 (expain it and maybe modify) -->
<!-- show the results (e.g. two/three panels) -->
<!-- show calculations? e.g area/distance? -->
<!-- comparing projections? == -->
<!-- - st_as_sf(x, coords = c("x","y")) -->
<!-- - st_crs(x) -->
<!-- - st_transform(x, crs) -->
<!-- - == -->
<!-- - !st_is_longlat(x) -->
<!-- - st_set_crs(x, crs) -->
<!-- - st_bbox -->
<!-- - st_wrap_dateline -->

The dataset `cycle_hire_osm` represents all cycle hire locations across London, taken from OpenStreetMap (OSM).
It is automatically loaded by the **spData** package, meaning we do not have to load it, and its CRS can be queried as follows:

```{r}
st_crs(cycle_hire_osm)
```

CRS in R can be described as an `epsg` code or a `proj4string` definition, as described in section \@ref(crs-in-r).
Let's create a new version of `cycle_hire_osm` in a projected CRS, using the `epsg` number of 27700:

```{r}
cycle_hire_projected = st_transform(cycle_hire_osm, 27700)
st_crs(cycle_hire_projected)
```

Note that the result shows that the `epsg` has been updated and that `proj4string` element of the CRS now contains, among other things `+proj=tmerc` (meaning it is a projected CRS using the [tranverse Mercator](https://en.wikipedia.org/wiki/Transverse_Mercator_projection) projection) and `+units=m` (meaning the units of the coordinates are meters).
Another function, from the **rgdal** library, provides a note containing the name of the CRS:

```{r}
crs_codes = rgdal::make_EPSG()[1:2]
dplyr::filter(crs_codes, code == 27700)
```

The result shows that the EPSG code 27700 represents the British National Grid, a result that could have been found by searching online for "[CRS 27700](https://www.google.com/search?q=CRS+27700)".
<!-- This projection is clearly inappropriate for the data: the coordinates represent degrees of longitude and latitude, and this can also be seen by plotting it over a basemap, e.g. with the **mapview** package: `mapview::mapview(cycle_hire)`. -->
The formula that converts a geographic point into a point on the surface of the Earth is provided by the `proj4string` element of the `crs` (see [proj4.org](http://proj4.org/) for further details):

```{r}
st_crs(27700)$proj4string
```

```{block2 type='rmdnote'}
The EPSG code can be found inside the `crs` attribute of the object's geometry.
It is hidden from view for most of the time except when the object is printed but can be can identified and set using the `st_crs` function, for example `st_crs(cycle_hire_osm)$epsg`.
```

### Raster data

The basic concepts of CRS apply to both vector and raster data model.
However, there are important differences in reprojection of vectors and rasters.
Transformation of CRS in vector data changes coordinates of each vertex. This do not apply to raster data.
Rasters are are composed of rectangular cells of the same size (expressed by map units, such as degrees or meters).
To preserve this property, it is impossible to transform coordinates of cells separately.
This entails that a new raster could have a different number of columns and rows, and therefore different number of cells that the original one.
<!-- rasters: transformation means change of the coordinates of (special case of resampling) -->
<!-- changes in dimensions, resolution, extent -->
<!-- change shape and attributes) -->
Therefore, values of these new cells need to be estimated after a geometric operation is completed.
The `projectRaster()` function's role is to reproject `Raster*` objects into a new object with another coordinate reference system. 
Compared to `st_tranform()`, `projectRaster()` only accepts the `proj4string` definitions.
Let's take a look at two examples of raster transformation - using categorical and continuous data.

Land cover data are usually represented by categorical maps.
The `nlcd2011.tif` file provides information for a small area in Utah, USA obtained from [National Land Cover Database 2011](https://www.mrlc.gov/nlcd2011.php) in the NAD83 / UTM zone 12N CRS.

```{r}
cat_raster = raster(system.file("raster/nlcd2011.tif", package = "spDataLarge"))
cat_raster
```

In this region, 14 land cover classes were distinguished^[Full list of NLCD2011 land cover classes can be found at https://www.mrlc.gov/nlcd11_leg.php]:

```{r}
unique(cat_raster)
```

When reprojecting categorical raster, we need to ensure that our new estimated values would still have values of our original classes.
This could be done using the nearest neighbor method (`ngb`).
In this method, value of the output cell is calculated based on the nearest cell center of the input raster.

For example, we want to change the CRS to WGS 84.  
<!-- when can it be useful? maybe when all other data is in this projection -->
The first step to do so is to obtain the proj4 definition of this CRS, which can be done using the [http://spatialreference.org](http://spatialreference.org/ref/epsg/wgs-84/) webpage. 
The second and last step is to define the reprojection method in the `projectRaster()` function, which in case of categorical data is the nearest neighbor method (`ngb`):

```{r}
wgs84 = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
cat_raster_wgs84 = projectRaster(cat_raster, crs = wgs84, method = "ngb")
cat_raster_wgs84
```

Many properties of the new object differs from the previous one, which include the number of columns and rows (and therefore number of cells), resolution (transformed from meters into degrees), and extent.
In the same time, it keeps the same land cover classes - `unique(cat_raster_wgs84)`.
<!-- freq(cat_raster_wgs84) -->
<!-- freq(cat_raster) -->

This process of reprojection is almost identical for continuous data.
The `srtm.tif` file contains digital elevation model for the same area in Utah from [the Shuttle Radar Topography Mission (SRTM)](https://www2.jpl.nasa.gov/srtm/).
Each value in this raster represents elevation measured in meters.

```{r}
con_raster = raster(system.file("raster/srtm.tif", package = "spDataLarge"))
con_raster
```

The nearest neighbor method should not be used for continuous raster data, as we want to preserve gradual changes in values.
Alternatively, continuous data could be reprojected in the **raster** package using the bilinear method. 
In this technique, value of the output cell is calculated based on four nearest cells in the original raster. 
The new value is a weighted average of values from these four cells, adjusted for their distance from the center of the output cell. 

```{r}
con_raster_wgs84 = projectRaster(con_raster, crs = wgs84, method = "bilinear")
con_raster_wgs84
```

Reprojection of continuous rasters also change spatial properties, such as the number of cells, resolution, and extent.
It also slightly modifies values in the new raster, which can be seen by comparing the outputs of the `summary()` function between `con_raster` and `con_raster_wgs84`.

```{r, eval=FALSE}
summary(con_raster)
summary(con_raster_wgs84)
```

<!-- why new na? -->

<!-- - an issue of resampling (comparision of old and new values) -->
<!-- res option in projectRaster? -->
<!-- note1: in most of the cases reproject vector, not raster-->
<!-- note2: equal area projections are the best for raster calculations -->
<!-- q: should we mentioned gdal_transform? -->

<!-- ideas and questions -->
<!-- 1. what's important for vector transformations? -->
<!-- - simplifications -->
<!-- - st_cast -->
<!-- - do we really need - Affine transformations, Translating, Scaling, Rotating, Reflecting, Shearing - are they useful? -->
<!-- 2. what's important for raster transformations? -->
<!-- - should we move some content from ch4 here? such as aggregate() and disaggregate() from 3.3.8  -->
<!-- 3. what's important for both? -->
<!-- - raster to vector -->
<!-- - vector to raster -->
<!-- 4. should the intro example have buffer in latlon? -->

### Exercises

<!-- 1. Test how transformation of data into transverse Mercator change data. -->
<!-- Why is that? -->
<!-- Now try to inverse it back into WGS 84.  -->
<!-- What happened? Why? -->
<!-- https://github.com/r-spatial/sf/issues/509 -->
<!-- ```{r} -->
<!-- world_tmerc = st_transform(world, "+proj=tmerc") -->
<!-- plot(world_tmerc$geom) -->
<!--  world_4326 = st_transform(world_tmerc, 4326) -->
<!-- plot(world_4326$geom) -->
<!-- ``` -->
<!-- 2. Try to reproject categorical data using a bilinear interpolation method. What's wrong? -->
<!-- ```{r} -->
<!-- wgs84 = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs" -->
<!-- cat_raster_wgs84 = projectRaster(cat_raster, crs = wgs84, method = "bilinear") -->
<!-- cat_raster_wgs84 -->
<!-- ``` -->
<!-- Try to reproject continuous data using a ngb interpolation method. What's wrong? -->
<!-- ```{r} -->
<!-- con_raster = raster(system.file("raster/srtm.tif", package="spDataLarge")) -->
<!-- con_raster_wgs84 = projectRaster(con_raster, crs = wgs84, method = "ngb") -->
<!-- con_raster_wgs84 -->
<!-- ``` -->
